"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutocompleteContext = void 0;
const constants_1 = require("../../constants");
const member_1 = require("../member");
const permissions_1 = require("../permissions");
const user_1 = require("../user");
const commandContext_1 = require("./commandContext");
/** Represents a autocomplete interaction context. */
class AutocompleteContext {
    /**
     * @param creator The instantiating creator.
     * @param data The interaction data.
     * @param respond The response function for the interaction.
     */
    constructor(creator, data, respond) {
        /** The time when the interaction was created. */
        this.invokedAt = Date.now();
        /** Whether the interaction has been responded to. */
        this.responded = false;
        this.creator = creator;
        this._respond = respond;
        this.data = data;
        this.interactionToken = data.token;
        this.interactionID = data.id;
        this.channelID = data.channel_id;
        this.guildID = 'guild_id' in data ? data.guild_id : undefined;
        this.member = 'guild_id' in data ? new member_1.Member(data.member, this.creator, data.guild_id) : undefined;
        this.user = new user_1.User('guild_id' in data ? data.member.user : data.user, this.creator);
        this.options = commandContext_1.CommandContext.convertOptions(data.data.options);
        this.subcommands = commandContext_1.CommandContext.getSubcommandArray(data.data.options);
        this.focused = AutocompleteContext.getFocusedOption(data.data.options);
        this.appPermissions = data.app_permissions ? new permissions_1.Permissions(BigInt(data.app_permissions)) : undefined;
    }
    /** Whether the interaction has expired. Interactions last 15 minutes. */
    get expired() {
        return this.invokedAt + 1000 * 60 * 15 < Date.now();
    }
    /**
     * Sends the results of an autocomplete interaction.
     * @param choices The choices to display
     */
    async sendResults(choices) {
        if (this.responded)
            return false;
        this.responded = true;
        await this._respond({
            status: 200,
            body: {
                type: constants_1.InteractionResponseType.APPLICATION_COMMAND_AUTOCOMPLETE_RESULT,
                data: { choices }
            }
        });
        return true;
    }
    /** @private */
    static convertOptions(options) {
        const convertedOptions = {};
        for (const option of options) {
            if ('options' in option)
                convertedOptions[option.name] = option.options ? commandContext_1.CommandContext.convertOptions(option.options) : {};
            else
                convertedOptions[option.name] = 'value' in option && option.value !== undefined ? option.value : {};
        }
        return convertedOptions;
    }
    /** @private */
    static getFocusedOption(options) {
        for (const option of options) {
            if ('focused' in option && option.focused) {
                return option.name;
            }
            if ('options' in option && option.options) {
                const nextResult = AutocompleteContext.getFocusedOption(option.options);
                if (nextResult)
                    return nextResult;
            }
        }
    }
}
exports.AutocompleteContext = AutocompleteContext;
