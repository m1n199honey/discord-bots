"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.CommandContext = void 0;
const constants_1 = require("../../constants");
const user_1 = require("../user");
const collection_1 = require("../../util/collection");
const channel_1 = require("../channel");
const role_1 = require("../role");
const resolvedMember_1 = require("../resolvedMember");
const message_1 = require("../message");
const modalSendableContext_1 = require("./modalSendableContext");
/** Context representing a command interaction. */
class CommandContext extends modalSendableContext_1.ModalSendableContext {
    /**
     * @param creator The instantiating creator.
     * @param data The interaction data for the context.
     * @param respond The response function for the interaction.
     * @param webserverMode Whether the interaction was from a webserver.
     * @param deferEphemeral Whether the context should auto-defer ephemeral messages.
     * @param useTimeout Whether to use the deferral timeout.
     */
    constructor(creator, data, respond, webserverMode, deferEphemeral = false, useTimeout = true) {
        super(creator, data, respond);
        /** The resolved users of the interaction. */
        this.users = new collection_1.Collection();
        /** The resolved members of the interaction. */
        this.members = new collection_1.Collection();
        /** The resolved roles of the interaction. */
        this.roles = new collection_1.Collection();
        /** The resolved channels of the interaction. */
        this.channels = new collection_1.Collection();
        /** The resolved messages of the interaction. */
        this.messages = new collection_1.Collection();
        /** The resolved attachments of the interaction. */
        this.attachments = new collection_1.Collection();
        this.data = data;
        this.webserverMode = webserverMode;
        this.commandType = data.data.type;
        this.commandName = data.data.name;
        this.commandID = data.data.id;
        if (data.data.target_id)
            this.targetID = data.data.target_id;
        this.options = data.data.options ? CommandContext.convertOptions(data.data.options) : {};
        this.subcommands = data.data.options ? CommandContext.getSubcommandArray(data.data.options) : [];
        if (data.data.resolved) {
            if (data.data.resolved.users)
                Object.keys(data.data.resolved.users).forEach((id) => this.users.set(id, new user_1.User(data.data.resolved.users[id], this.creator)));
            if (data.data.resolved.members)
                Object.keys(data.data.resolved.members).forEach((id) => this.members.set(id, new resolvedMember_1.ResolvedMember(data.data.resolved.members[id], data.data.resolved.users[id], this.creator, this.guildID)));
            if (data.data.resolved.roles)
                Object.keys(data.data.resolved.roles).forEach((id) => this.roles.set(id, new role_1.Role(data.data.resolved.roles[id], this.creator)));
            if (data.data.resolved.channels)
                Object.keys(data.data.resolved.channels).forEach((id) => this.channels.set(id, new channel_1.Channel(data.data.resolved.channels[id])));
            if (data.data.resolved.messages)
                Object.keys(data.data.resolved.messages).forEach((id) => this.messages.set(id, new message_1.Message(data.data.resolved.messages[id], this.creator)));
            if (data.data.resolved.attachments)
                Object.keys(data.data.resolved.attachments).forEach((id) => this.attachments.set(id, data.data.resolved.attachments[id]));
        }
        // Auto-defer if no response was given in 2 seconds
        if (useTimeout)
            this._timeout = setTimeout(() => this.defer(deferEphemeral || false), 2000);
    }
    /**
     * The target message of the interaction.
     * Will be `null` if it's not from a message command.
     */
    get targetMessage() {
        if (this.commandType === constants_1.ApplicationCommandType.MESSAGE && this.targetID)
            return this.messages.get(this.targetID);
        else
            return null;
    }
    /**
     * The target user of the interaction.
     * Will be `null` if it's not from a user command.
     */
    get targetUser() {
        if (this.commandType === constants_1.ApplicationCommandType.USER && this.targetID)
            return this.users.get(this.targetID);
        else
            return null;
    }
    /**
     * The target member of the interaction.
     * Will be `null` if it's not from a user command.
     */
    get targetMember() {
        if (this.commandType === constants_1.ApplicationCommandType.USER && this.targetID)
            return this.members.get(this.targetID);
        else
            return null;
    }
    /** @private */
    static convertOptions(options) {
        const convertedOptions = {};
        for (const option of options) {
            if ('options' in option)
                convertedOptions[option.name] = option.options ? CommandContext.convertOptions(option.options) : {};
            else
                convertedOptions[option.name] = 'value' in option && option.value !== undefined ? option.value : {};
        }
        return convertedOptions;
    }
    /** @private */
    static getSubcommandArray(options) {
        const result = [];
        for (const option of options) {
            if ('options' in option || !('value' in option))
                result.push(option.name, ...(option.options ? CommandContext.getSubcommandArray(option.options) : []));
        }
        return result;
    }
}
exports.CommandContext = CommandContext;
exports.Context = CommandContext;
